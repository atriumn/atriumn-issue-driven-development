name: 'Atriumn Pipeline Runner'
description: 'Runs the Atriumn AI-driven development pipeline phases'
author: 'Atriumn'

inputs:
  phase:
    description: 'Pipeline phase to run (research, plan, implement, validate)'
    required: true
  issue_number:
    description: 'Issue number'
    required: true
  pr_number:
    description: 'Pull request number'
    required: true
  head_sha:
    description: 'SHA of the commit to run checks against'
    required: true
  task_description:
    description: 'Task description for the AI'
    required: false
  claude_code_oauth_token:
    description: 'Claude Code OAuth token'
    required: true
  github_token:
    description: 'GitHub token'
    required: true

runs:
  using: 'composite'
  steps:
    - name: 'Create Status Check: In Progress'
      id: create_check
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const phase = '${{ inputs.phase }}';
          const phaseTitle = phase.charAt(0).toUpperCase() + phase.slice(1);
          const checkName = `Atriumn Phase: ${phaseTitle}`;

          const { data: check } = await github.rest.checks.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            name: checkName,
            head_sha: '${{ inputs.head_sha }}',
            status: 'in_progress',
            output: {
              title: `Running ${phaseTitle}`,
              summary: `The AI agent is currently executing the ${phase} phase.`
            }
          });
          core.setOutput('check_id', check.id);

    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        ref: feature/issue-${{ inputs.issue_number }}
        token: ${{ inputs.github_token }}

    - name: Ensure output directories exist
      run: |
        mkdir -p thoughts/shared/{research,decisions,plans,validation}/tmp
      shell: bash

    - name: Load task-pack prompt for phase
      id: load_prompt
      run: |
        # Check for local override first
        if [[ -f ".atriumn/task-packs/${{ inputs.phase }}.md" ]]; then
          echo "Using local task-pack override for ${{ inputs.phase }}"
          PROMPT_PATH=".atriumn/task-packs/${{ inputs.phase }}.md"
        else
          # Fetch from central repository (default behavior)
          echo "Fetching latest ${{ inputs.phase }} task-pack from Atriumn..."
          TEMP_DIR=$(mktemp -d)
          PROMPT_PATH="$TEMP_DIR/${{ inputs.phase }}.md"
          
          curl -sSL "https://raw.githubusercontent.com/atriumn/atriumn-issue-driven-development/main/templates/pipeline/.atriumn/task-packs/${{ inputs.phase }}.md" \
            -o "$PROMPT_PATH" || {
              echo "Failed to fetch task-pack for phase: ${{ inputs.phase }}" >&2
              exit 1
            }
        fi
        
        if [[ ! -f "$PROMPT_PATH" ]]; then
          echo "Missing task-pack prompt: $PROMPT_PATH" >&2
          exit 1
        fi
        
        # Read and escape the prompt for JSON embedding
        PROMPT_CONTENT=$(cat "$PROMPT_PATH")
        echo "prompt<<EOF" >> $GITHUB_ENV
        echo "$PROMPT_CONTENT" >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV
      shell: bash

    - name: Run Claude Code Agent
      id: claude
      uses: anthropics/claude-code-action@beta
      with:
        mode: agent
        claude_code_oauth_token: ${{ inputs.claude_code_oauth_token }}
        github_token: ${{ inputs.github_token }}
        timeout_minutes: 40
        allowed_tools: "Read,Write,Edit,MultiEdit,Grep,Glob,LS,TodoWrite,Bash"
        # MCP servers could be added here when Claude Code supports them:
        # mcp_servers: "github-context,codebase-search,test-runner"
        direct_prompt: |
          ${{ env.prompt }}
          ---
          # Context variables:
          feature_ref = "feature/issue-${{ inputs.issue_number }}"
          issue_number = "${{ inputs.issue_number }}"
          repository = "${{ github.repository }}"
          task_description = "${{ inputs.task_description }}"
          phase = "${{ inputs.phase }}"

    - name: Commit & push artifacts
      run: |
        git config user.name "atriumn-bot"
        git config user.email "bot@atriumn.dev"
        
        # Check if Claude suggested any workflows
        if [ -d ".atriumn/suggested-workflows" ] && ls .atriumn/suggested-workflows/*.yml 2>/dev/null; then
          echo "üìã Claude suggested workflow files in .atriumn/suggested-workflows/"
          echo "These can be manually reviewed and moved to .github/workflows/ if approved"
          ls -la .atriumn/suggested-workflows/
        fi
        
        # Safety check: only move NEW workflow files Claude created (not existing ones)
        # First, get list of workflow files that existed before Claude's changes
        existing_workflows=$(git ls-tree HEAD .github/workflows/ 2>/dev/null | awk '{print $4}' | xargs -I {} basename {} || true)
        
        # Check if Claude created any NEW workflow files
        new_workflows_found=false
        for file in .github/workflows/*.yml; do
          if [[ -f "$file" && "$(basename $file)" != "development-pipeline.yml" ]]; then
            filename=$(basename "$file")
            # Check if this file existed in the repo before
            if ! echo "$existing_workflows" | grep -q "^$filename$"; then
              # This is a NEW file Claude created
              if [[ "$new_workflows_found" == "false" ]]; then
                echo "üìã Claude created new workflow files - moving to .atriumn/suggested-workflows/ for review"
                mkdir -p .atriumn/suggested-workflows
                new_workflows_found=true
              fi
              echo "  Moving new workflow: $filename"
              mv "$file" .atriumn/suggested-workflows/ 2>/dev/null || true
            fi
          fi
        done
        
        if [[ "$new_workflows_found" == "true" ]]; then
          echo "‚úÖ New workflows moved to .atriumn/suggested-workflows/ for manual review"
          echo "   Existing workflows remain unchanged in .github/workflows/"
          
          # Create a tracking issue for workflow suggestions (only on implement phase)
          if [[ "${{ inputs.phase }}" == "implement" ]]; then
            echo "üìù Creating tracking issue for workflow suggestions..."
            
            # List all suggested workflows
            suggested_files=$(ls -1 .atriumn/suggested-workflows/*.yml 2>/dev/null | xargs -I {} basename {} | tr '\n' ',' | sed 's/,$//' || echo "")
            
            if [[ -n "$suggested_files" ]]; then
              # Create a test branch for the workflow suggestions
              test_branch="test/workflow-suggestions-${{ inputs.issue_number }}"
              git checkout -b "$test_branch"
              
              # Move workflows to active location in test branch
              cp -r .atriumn/suggested-workflows/*.yml .github/workflows/ 2>/dev/null || true
              
              # Create detailed issue body with workflow analysis
              issue_body="## Workflow Suggestions from AI Implementation

The AI assistant created workflow suggestions during the implementation of #${{ inputs.issue_number }}. A test branch has been created for you to review and test these workflows.

### üöÄ Quick Start - Test These Workflows

\`\`\`bash
# Fetch and checkout the test branch
git fetch origin $test_branch
git checkout $test_branch

# The workflows are already activated in this branch
# You can now test them locally or push to see them in action

# To test a specific workflow locally
act -W .github/workflows/[workflow-name].yml  # Using act for local testing

# Or push to test on GitHub
git push origin $test_branch
\`\`\`

### üìã Suggested Workflows
"
              for file in .atriumn/suggested-workflows/*.yml; do
                if [[ -f "$file" ]]; then
                  filename=$(basename "$file")
                  
                  # Extract workflow metadata
                  workflow_name=$(grep "^name:" "$file" | head -1 | sed 's/name: *//' || echo "Unnamed Workflow")
                  triggers=$(grep -A5 "^on:" "$file" | grep -E "^\s+(push|pull_request|workflow_dispatch|schedule):" | sed 's/^\s*/  - /' | tr '\n' ' ' || echo "")
                  jobs_count=$(grep -c "^\s\s[a-zA-Z].*:$" "$file" || echo "0")
                  lines_count=$(wc -l < "$file")
                  
                  issue_body="${issue_body}
#### üìÑ \`${filename}\`

**Workflow Name:** ${workflow_name}
**Triggers:** ${triggers:-Not specified}
**Jobs:** ${jobs_count} job(s)
**Size:** ${lines_count} lines

<details>
<summary>Click to view full workflow</summary>

\`\`\`yaml
$(cat "$file")
\`\`\`

</details>

##### Purpose & Impact Analysis
"
                  # Analyze the workflow purpose
                  if grep -q "test" "$file"; then
                    issue_body="${issue_body}- üß™ **Testing**: This workflow adds automated testing capabilities
"
                  fi
                  if grep -q "deploy" "$file"; then
                    issue_body="${issue_body}- üöÄ **Deployment**: This workflow handles deployment automation
"
                  fi
                  if grep -q "visual\|screenshot" "$file"; then
                    issue_body="${issue_body}- üëÅÔ∏è **Visual Testing**: This workflow performs visual regression testing
"
                  fi
                  if grep -q "lint\|format" "$file"; then
                    issue_body="${issue_body}- üé® **Code Quality**: This workflow enforces code style and quality
"
                  fi
                  
                  issue_body="${issue_body}
##### Potential Risks
"
                  # Check for potential risks
                  if grep -q "secrets\." "$file"; then
                    issue_body="${issue_body}- ‚ö†Ô∏è Uses secrets - review secret requirements
"
                  fi
                  if grep -q "push.*main\|push.*master" "$file"; then
                    issue_body="${issue_body}- ‚ö†Ô∏è Triggers on main/master branch pushes
"
                  fi
                  if grep -q "npm publish\|docker push" "$file"; then
                    issue_body="${issue_body}- ‚ö†Ô∏è Publishes artifacts - review permissions
"
                  fi
                  
                  issue_body="${issue_body}
---
"
                fi
              done
              
              # Commit the test branch
              git add -A
              git commit -m "test: Activate workflow suggestions for testing

Related to #${{ inputs.issue_number }}
This branch activates the suggested workflows for testing purposes." || true
              
              git push origin "$test_branch" || true
              
              # Switch back to original branch
              git checkout "feature/issue-${{ inputs.issue_number }}"
              
              issue_body="${issue_body}
### üß™ Test Branch Created

A test branch \`$test_branch\` has been created with all suggested workflows activated. You can:

1. **Test locally**: Check out the branch and test the workflows
2. **Create test PR**: Open a draft PR from this branch to see workflows in action
3. **Run with act**: Use [act](https://github.com/nektos/act) to test workflows locally

### üìù Review Checklist

- [ ] Review workflow triggers and ensure they match your needs
- [ ] Check job permissions and secret requirements
- [ ] Verify workflow doesn't conflict with existing CI/CD
- [ ] Test workflow execution (locally or via PR)
- [ ] Review any published artifacts or deployments
- [ ] Ensure workflow follows your team's conventions

### ‚úÖ Adoption Options

After testing, you have several options:

#### Option 1: Accept All Workflows
\`\`\`bash
git checkout $test_branch
git push origin $test_branch:main  # or create PR
\`\`\`

#### Option 2: Cherry-Pick Specific Workflows
\`\`\`bash
git checkout main
git checkout $test_branch -- .github/workflows/[workflow-name].yml
git commit -m \"feat: Add [workflow-name] workflow\"
\`\`\`

#### Option 3: Adopt with Modifications
\`\`\`bash
git checkout $test_branch
# Edit workflows as needed
git commit -am \"feat: Add customized workflows\"
git push origin $test_branch
# Create PR for review
\`\`\`

### üîó Related Links
- Original Issue: #${{ inputs.issue_number }}
- Implementation PR: #${{ inputs.pr_number }}
- Test Branch: [\`$test_branch\`](../../tree/$test_branch)
- [GitHub Actions Documentation](https://docs.github.com/en/actions)

### üè∑Ô∏è Labels
\`workflow-suggestion\` \`needs-review\` \`has-test-branch\`

---
*This issue was automatically created to track workflow suggestions from the AI pipeline. The test branch allows you to safely evaluate these workflows before adoption.*"

              # Create the tracking issue and capture the issue number
              issue_output=$(gh issue create \
                --repo "${{ github.repository }}" \
                --title "Review Workflow Suggestions from Issue #${{ inputs.issue_number }}" \
                --body "$issue_body" \
                --label "workflow-suggestion,needs-review,has-test-branch" \
                2>&1) || echo "Note: Could not create tracking issue"
                
              # Extract issue number if created successfully
              if [[ "$issue_output" =~ ([0-9]+)$ ]]; then
                created_issue="${BASH_REMATCH[1]}"
                echo "‚úÖ Created tracking issue #$created_issue with test branch $test_branch"
              fi
            fi
          fi
        fi
        
        git add -A
        if git diff --cached --quiet; then
          echo "No changes to commit."
        else
          git commit -m "feat(${{ inputs.phase }}): AI-generated artifacts for issue #${{ inputs.issue_number }}"
          git push origin "feature/issue-${{ inputs.issue_number }}"
        fi
      shell: bash
    
    - name: 'Update Status Check: Success'
      if: success()
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const phase = '${{ inputs.phase }}';
          const phaseTitle = phase.charAt(0).toUpperCase() + phase.slice(1);
          const nextPhase = {
            'research': 'plan',
            'plan': 'implement', 
            'implement': 'validate',
            'validate': null
          }[phase];
          
          let summary = `The AI agent successfully completed the ${phase} phase. The generated artifacts have been committed.`;
          
          // For validate phase, provide a summary of validation results
          if (phase === 'validate') {
            const fs = require('fs');
            const path = require('path');
            
            try {
              // First try to read the dedicated validation report
              const validationReportPath = path.join('thoughts', 'shared', 'validation', `issue-${{ inputs.issue_number }}-validation-report.md`);
              const decisionsPath = path.join('thoughts', 'shared', 'decisions', `issue-${{ inputs.issue_number }}.md`);
              
              let validationContent = '';
              let reportLocation = '';
              
              // Check for dedicated validation report first
              if (fs.existsSync(validationReportPath)) {
                validationContent = fs.readFileSync(validationReportPath, 'utf8');
                reportLocation = `thoughts/shared/validation/issue-${{ inputs.issue_number }}-validation-report.md`;
              } else if (fs.existsSync(decisionsPath)) {
                // Fall back to decisions file if no dedicated report
                validationContent = fs.readFileSync(decisionsPath, 'utf8');
                reportLocation = `thoughts/shared/decisions/issue-${{ inputs.issue_number }}.md`;
              }
              
              if (validationContent) {
                // Parse validation status from the content
                const hasPassedStatus = validationContent.includes('status: "passed"') || validationContent.includes('Production Readiness**: Ready');
                const hasWarnings = validationContent.includes('passed_with_warnings');
                const hasFailed = validationContent.includes('status: "failed"') || validationContent.includes('Production Readiness**: Failed');
                const hasAutomatedTests = validationContent.includes('‚úÖ') && (validationContent.includes('Automated Tests') || validationContent.includes('Unit Tests'));
                const hasManualVerification = validationContent.includes('‚úÖ') && validationContent.includes('Manual Verification');
                
                // Extract executive summary if present
                let executiveSummary = '';
                const summaryMatch = validationContent.match(/## Executive Summary\n(.+?)(?=\n##|\n\n##)/s);
                if (summaryMatch) {
                  executiveSummary = summaryMatch[1].trim();
                }
                
                // Build the summary
                summary = `## Validation Complete! ${hasPassedStatus ? '‚úÖ' : hasWarnings ? '‚ö†Ô∏è' : hasFailed ? '‚ùå' : 'üîç'}\n\n`;
                
                if (executiveSummary) {
                  summary += `${executiveSummary}\n\n`;
                }
                
                summary += `### Validation Results\n`;
                summary += `- **Status**: ${hasPassedStatus ? '‚úÖ Passed' : hasWarnings ? '‚ö†Ô∏è Passed with Warnings' : hasFailed ? '‚ùå Failed' : 'üîç In Review'}\n`;
                summary += `- **Automated Tests**: ${hasAutomatedTests ? '‚úÖ Passing' : '‚ö†Ô∏è Review Required'}\n`;
                summary += `- **Manual Verification**: ${hasManualVerification ? '‚úÖ Complete' : '‚ö†Ô∏è Review Required'}\n\n`;
                
                // Extract any critical issues
                if (validationContent.includes('## Issues Found')) {
                  const issuesMatch = validationContent.match(/## Issues Found\n(.+?)(?=\n##|\n\n##)/s);
                  if (issuesMatch && !issuesMatch[1].includes('[List any issues')) {
                    summary += `### Issues Found\n${issuesMatch[1].trim()}\n\n`;
                  }
                }
                
                summary += `### Full Report\n`;
                summary += `üìÑ Full validation report available at: \`${reportLocation}\`\n\n`;
                summary += `Please review the complete validation report and approve if everything meets the acceptance criteria.`;
              } else {
                summary += ` Validation completed. Please check the artifacts for validation results.`;
              }
            } catch (error) {
              console.error('Failed to read validation results:', error);
              summary += ` Please check the validation report in the thoughts/shared/validation/ directory for details.`;
            }
          } else {
            summary += ` Please review the changes in the PR and provide your approval to proceed to the next phase.`;
          }
          
          await github.rest.checks.update({
            owner: context.repo.owner,
            repo: context.repo.repo,
            check_run_id: ${{ steps.create_check.outputs.check_id }},
            status: 'completed',
            conclusion: 'success',
            output: {
              title: `${phaseTitle} Phase Complete!`,
              summary: summary
            }
          });
          
          // Update PR description with progress
          const { data: pr } = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: ${{ inputs.pr_number }}
          });
          
          const phaseChecks = {
            research: phase === 'research' || phase === 'plan' || phase === 'implement' || phase === 'validate',
            plan: phase === 'plan' || phase === 'implement' || phase === 'validate',
            implement: phase === 'implement' || phase === 'validate',
            validate: phase === 'validate'
          };
          
          const updatedBody = pr.body.replace(
            /- \[[x ]\] Research\n- \[[x ]\] Plan\n- \[[x ]\] Implement\n- \[[x ]\] Validate/,
            `- [${phaseChecks.research ? 'x' : ' '}] Research\n- [${phaseChecks.plan ? 'x' : ' '}] Plan\n- [${phaseChecks.implement ? 'x' : ' '}] Implement\n- [${phaseChecks.validate ? 'x' : ' '}] Validate`
          );
          
          await github.rest.pulls.update({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: ${{ inputs.pr_number }},
            body: updatedBody
          });
          
          // Dismiss all previous reviews when phase completes to require fresh approval
          const { data: reviews } = await github.rest.pulls.listReviews({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: ${{ inputs.pr_number }}
          });
          
          for (const review of reviews) {
            if (review.state === 'APPROVED') {
              await github.rest.pulls.dismissReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: ${{ inputs.pr_number }},
                review_id: review.id,
                message: `Phase ${phase} completed. Dismissing old approval to require fresh review for next phase.`
              });
            }
          }

    - name: 'Update Status Check: Failure'
      if: failure()
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const phase = '${{ inputs.phase }}';
          const phaseTitle = phase.charAt(0).toUpperCase() + phase.slice(1);
          await github.rest.checks.update({
            owner: context.repo.owner,
            repo: context.repo.repo,
            check_run_id: ${{ steps.create_check.outputs.check_id }},
            status: 'completed',
            conclusion: 'failure',
            output: {
              title: `${phaseTitle} Phase Failed`,
              summary: `The AI agent encountered an error during the ${phase} phase. Please check the workflow logs for details.`
            }
          });