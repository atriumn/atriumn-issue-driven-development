name: 'Atriumn Pipeline Runner'
description: 'Runs the Atriumn AI-driven development pipeline phases'
author: 'Atriumn'

inputs:
  phase:
    description: 'Pipeline phase to run (research, plan, implement, validate)'
    required: true
  issue_number:
    description: 'Issue number'
    required: true
  pr_number:
    description: 'Pull request number'
    required: true
  head_sha:
    description: 'SHA of the commit to run checks against'
    required: true
  task_description:
    description: 'Task description for the AI'
    required: false
  claude_code_oauth_token:
    description: 'Claude Code OAuth token'
    required: true
  github_token:
    description: 'GitHub token'
    required: true

runs:
  using: 'composite'
  steps:
    - name: 'Create Status Check: In Progress'
      id: create_check
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const phase = '${{ inputs.phase }}';
          const phaseTitle = phase.charAt(0).toUpperCase() + phase.slice(1);
          const checkName = `Atriumn Phase: ${phaseTitle}`;

          const { data: check } = await github.rest.checks.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            name: checkName,
            head_sha: '${{ inputs.head_sha }}',
            status: 'in_progress',
            output: {
              title: `Running ${phaseTitle}`,
              summary: `The AI agent is currently executing the ${phase} phase.`
            }
          });
          core.setOutput('check_id', check.id);

    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        ref: feature/issue-${{ inputs.issue_number }}
        token: ${{ inputs.github_token }}

    - name: Ensure output directories exist
      run: |
        mkdir -p thoughts/shared/{research,decisions,plans,validation}/tmp
      shell: bash

    - name: Load task-pack prompt for phase
      id: load_prompt
      run: |
        # Check for local override first
        if [[ -f ".atriumn/task-packs/${{ inputs.phase }}.md" ]]; then
          echo "Using local task-pack override for ${{ inputs.phase }}"
          PROMPT_PATH=".atriumn/task-packs/${{ inputs.phase }}.md"
        else
          # Fetch from central repository (default behavior)
          echo "Fetching latest ${{ inputs.phase }} task-pack from Atriumn..."
          TEMP_DIR=$(mktemp -d)
          PROMPT_PATH="$TEMP_DIR/${{ inputs.phase }}.md"
          
          curl -sSL "https://raw.githubusercontent.com/atriumn/atriumn-issue-driven-development/main/templates/pipeline/.atriumn/task-packs/${{ inputs.phase }}.md" \
            -o "$PROMPT_PATH" || {
              echo "Failed to fetch task-pack for phase: ${{ inputs.phase }}" >&2
              exit 1
            }
        fi
        
        if [[ ! -f "$PROMPT_PATH" ]]; then
          echo "Missing task-pack prompt: $PROMPT_PATH" >&2
          exit 1
        fi
        
        # Read and escape the prompt for JSON embedding
        PROMPT_CONTENT=$(cat "$PROMPT_PATH")
        echo "prompt<<EOF" >> $GITHUB_ENV
        echo "$PROMPT_CONTENT" >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV
      shell: bash

    - name: Run Claude Code Agent
      id: claude
      uses: anthropics/claude-code-action@beta
      with:
        mode: agent
        claude_code_oauth_token: ${{ inputs.claude_code_oauth_token }}
        github_token: ${{ inputs.github_token }}
        timeout_minutes: 40
        allowed_tools: "Read,Write,Edit,MultiEdit,Grep,Glob,LS,TodoWrite"
        # MCP servers could be added here when Claude Code supports them:
        # mcp_servers: "github-context,codebase-search,test-runner"
        direct_prompt: |
          ${{ env.prompt }}
          ---
          # Context variables:
          feature_ref = "feature/issue-${{ inputs.issue_number }}"
          issue_number = "${{ inputs.issue_number }}"
          repository = "${{ github.repository }}"
          task_description = "${{ inputs.task_description }}"
          phase = "${{ inputs.phase }}"

    - name: Commit & push artifacts
      run: |
        git config user.name "atriumn-bot"
        git config user.email "bot@atriumn.dev"
        
        # Check if Claude suggested any workflows
        if [ -d ".atriumn/suggested-workflows" ] && ls .atriumn/suggested-workflows/*.yml 2>/dev/null; then
          echo "üìã Claude suggested workflow files in .atriumn/suggested-workflows/"
          echo "These can be manually reviewed and moved to .github/workflows/ if approved"
          ls -la .atriumn/suggested-workflows/
        fi
        
        # Safety check: if Claude accidentally put files in .github/workflows
        if ls .github/workflows/*.yml 2>/dev/null | grep -v development-pipeline.yml; then
          echo "‚ö†Ô∏è Moving workflow files to .atriumn/suggested-workflows/ for manual review"
          mkdir -p .atriumn/suggested-workflows
          for file in .github/workflows/*.yml; do
            if [[ "$(basename $file)" != "development-pipeline.yml" ]]; then
              mv "$file" .atriumn/suggested-workflows/ 2>/dev/null || true
            fi
          done
        fi
        
        git add -A
        if git diff --cached --quiet; then
          echo "No changes to commit."
        else
          git commit -m "feat(${{ inputs.phase }}): AI-generated artifacts for issue #${{ inputs.issue_number }}"
          git push origin "feature/issue-${{ inputs.issue_number }}"
        fi
      shell: bash
    
    - name: 'Update Status Check: Success'
      if: success()
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const phase = '${{ inputs.phase }}';
          const phaseTitle = phase.charAt(0).toUpperCase() + phase.slice(1);
          const nextPhase = {
            'research': 'plan',
            'plan': 'implement', 
            'implement': 'validate',
            'validate': null
          }[phase];
          
          let summary = `The AI agent successfully completed the ${phase} phase. The generated artifacts have been committed.`;
          
          // For validate phase, provide a summary of validation results
          if (phase === 'validate') {
            const fs = require('fs');
            const path = require('path');
            
            try {
              // First try to read the dedicated validation report
              const validationReportPath = path.join('thoughts', 'shared', 'validation', `issue-${{ inputs.issue_number }}-validation-report.md`);
              const decisionsPath = path.join('thoughts', 'shared', 'decisions', `issue-${{ inputs.issue_number }}.md`);
              
              let validationContent = '';
              let reportLocation = '';
              
              // Check for dedicated validation report first
              if (fs.existsSync(validationReportPath)) {
                validationContent = fs.readFileSync(validationReportPath, 'utf8');
                reportLocation = `thoughts/shared/validation/issue-${{ inputs.issue_number }}-validation-report.md`;
              } else if (fs.existsSync(decisionsPath)) {
                // Fall back to decisions file if no dedicated report
                validationContent = fs.readFileSync(decisionsPath, 'utf8');
                reportLocation = `thoughts/shared/decisions/issue-${{ inputs.issue_number }}.md`;
              }
              
              if (validationContent) {
                // Parse validation status from the content
                const hasPassedStatus = validationContent.includes('status: "passed"') || validationContent.includes('Production Readiness**: Ready');
                const hasWarnings = validationContent.includes('passed_with_warnings');
                const hasFailed = validationContent.includes('status: "failed"') || validationContent.includes('Production Readiness**: Failed');
                const hasAutomatedTests = validationContent.includes('‚úÖ') && (validationContent.includes('Automated Tests') || validationContent.includes('Unit Tests'));
                const hasManualVerification = validationContent.includes('‚úÖ') && validationContent.includes('Manual Verification');
                
                // Extract executive summary if present
                let executiveSummary = '';
                const summaryMatch = validationContent.match(/## Executive Summary\n(.+?)(?=\n##|\n\n##)/s);
                if (summaryMatch) {
                  executiveSummary = summaryMatch[1].trim();
                }
                
                // Build the summary
                summary = `## Validation Complete! ${hasPassedStatus ? '‚úÖ' : hasWarnings ? '‚ö†Ô∏è' : hasFailed ? '‚ùå' : 'üîç'}\n\n`;
                
                if (executiveSummary) {
                  summary += `${executiveSummary}\n\n`;
                }
                
                summary += `### Validation Results\n`;
                summary += `- **Status**: ${hasPassedStatus ? '‚úÖ Passed' : hasWarnings ? '‚ö†Ô∏è Passed with Warnings' : hasFailed ? '‚ùå Failed' : 'üîç In Review'}\n`;
                summary += `- **Automated Tests**: ${hasAutomatedTests ? '‚úÖ Passing' : '‚ö†Ô∏è Review Required'}\n`;
                summary += `- **Manual Verification**: ${hasManualVerification ? '‚úÖ Complete' : '‚ö†Ô∏è Review Required'}\n\n`;
                
                // Extract any critical issues
                if (validationContent.includes('## Issues Found')) {
                  const issuesMatch = validationContent.match(/## Issues Found\n(.+?)(?=\n##|\n\n##)/s);
                  if (issuesMatch && !issuesMatch[1].includes('[List any issues')) {
                    summary += `### Issues Found\n${issuesMatch[1].trim()}\n\n`;
                  }
                }
                
                summary += `### Full Report\n`;
                summary += `üìÑ Full validation report available at: \`${reportLocation}\`\n\n`;
                summary += `Please review the complete validation report and approve if everything meets the acceptance criteria.`;
              } else {
                summary += ` Validation completed. Please check the artifacts for validation results.`;
              }
            } catch (error) {
              console.error('Failed to read validation results:', error);
              summary += ` Please check the validation report in the thoughts/shared/validation/ directory for details.`;
            }
          } else {
            summary += ` Please review the changes in the PR and provide your approval to proceed to the next phase.`;
          }
          
          await github.rest.checks.update({
            owner: context.repo.owner,
            repo: context.repo.repo,
            check_run_id: ${{ steps.create_check.outputs.check_id }},
            status: 'completed',
            conclusion: 'success',
            output: {
              title: `${phaseTitle} Phase Complete!`,
              summary: summary
            }
          });
          
          // Update PR description with progress
          const { data: pr } = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: ${{ inputs.pr_number }}
          });
          
          const phaseChecks = {
            research: phase === 'research' || phase === 'plan' || phase === 'implement' || phase === 'validate',
            plan: phase === 'plan' || phase === 'implement' || phase === 'validate',
            implement: phase === 'implement' || phase === 'validate',
            validate: phase === 'validate'
          };
          
          const updatedBody = pr.body.replace(
            /- \[[x ]\] Research\n- \[[x ]\] Plan\n- \[[x ]\] Implement\n- \[[x ]\] Validate/,
            `- [${phaseChecks.research ? 'x' : ' '}] Research\n- [${phaseChecks.plan ? 'x' : ' '}] Plan\n- [${phaseChecks.implement ? 'x' : ' '}] Implement\n- [${phaseChecks.validate ? 'x' : ' '}] Validate`
          );
          
          await github.rest.pulls.update({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: ${{ inputs.pr_number }},
            body: updatedBody
          });
          
          // Dismiss all previous reviews when phase completes to require fresh approval
          const { data: reviews } = await github.rest.pulls.listReviews({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: ${{ inputs.pr_number }}
          });
          
          for (const review of reviews) {
            if (review.state === 'APPROVED') {
              await github.rest.pulls.dismissReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: ${{ inputs.pr_number }},
                review_id: review.id,
                message: `Phase ${phase} completed. Dismissing old approval to require fresh review for next phase.`
              });
            }
          }

    - name: 'Update Status Check: Failure'
      if: failure()
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const phase = '${{ inputs.phase }}';
          const phaseTitle = phase.charAt(0).toUpperCase() + phase.slice(1);
          await github.rest.checks.update({
            owner: context.repo.owner,
            repo: context.repo.repo,
            check_run_id: ${{ steps.create_check.outputs.check_id }},
            status: 'completed',
            conclusion: 'failure',
            output: {
              title: `${phaseTitle} Phase Failed`,
              summary: `The AI agent encountered an error during the ${phase} phase. Please check the workflow logs for details.`
            }
          });