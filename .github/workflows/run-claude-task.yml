name: Run Claude Task

on:
  workflow_call:
    inputs:
      task_pack_id:
        required: true
        type: string
      feature_ref:
        required: true
        type: string
      issue_number:
        required: true
        type: string
      task_description:
        required: true
        type: string
      task_name:
        required: false
        type: string
        default: research
      runner:
        required: false
        type: string
        default: claude-code
    secrets:
      CLAUDE_CODE_OAUTH_TOKEN:
        required: true
      GH_TOKEN_FOR_BOT:
        required: true

jobs:
  run:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      actions: read

    steps:
      - name: Checkout repository (caller repo)
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.feature_ref }}
          fetch-depth: 0

      - name: Checkout shared workflows
        uses: actions/checkout@v4
        with:
          repository: atriumn/atriumn-shared-workflows
          path: _shared

      - name: Resolve Task Pack (JSON) + Prompt
        id: resolve
        uses: actions/github-script@v7
        env:
          TASK_PACK_ID: ${{ inputs.task_pack_id }}
          FEATURE_REF:  ${{ inputs.feature_ref }}
          ISSUE_NUMBER: ${{ inputs.issue_number }}
          TASK_DESC:    ${{ inputs.task_description }}
          REPO_FULL:    ${{ github.repository }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const packPath = path.join('_shared', '.atrium-shared', 'taskpacks', `${process.env.TASK_PACK_ID}.json`);
            const pack = JSON.parse(fs.readFileSync(packPath, 'utf8'));

            function render(str, vars) {
              return str.replace(/\$\{(\w+)\}/g, (_, k) => String(vars[k] ?? ''));
            }

            const vars = {
              feature_ref: process.env.FEATURE_REF,
              issue_number: process.env.ISSUE_NUMBER,
              task_description: process.env.TASK_DESC,
              repository: process.env.REPO_FULL,
            };

            const outputPath = render(pack.output_path_template, vars);
            vars.output_path = outputPath;

            const promptPath = path.join('_shared', pack.prompt_template_path);
            const rawPrompt = fs.readFileSync(promptPath, 'utf8');
            const directPrompt = render(rawPrompt, vars);

            core.setOutput('allowed_tools', JSON.stringify(pack.allowed_tools || []));
            core.setOutput('direct_prompt', directPrompt);
            core.setOutput('output_path', outputPath);
            core.setOutput('check_name', pack.check_name || 'Claude Task');
            core.setOutput('labels', JSON.stringify(pack.labels || []));
            core.setOutput('pack_id', pack.id);
            core.setOutput('pack_version', String(pack.version || '1'));

      - name: Ensure output directory exists (filesystem only)
        run: |
          mkdir -p "$(dirname '${{ steps.resolve.outputs.output_path }}')"

      - name: Run Claude Code
        if: ${{ inputs.runner == 'claude-code' }}
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token:            ${{ secrets.GH_TOKEN_FOR_BOT }}
          mode: agent
          timeout_minutes: 40
          max_turns: 40
          allowed_tools: ${{ steps.resolve.outputs.allowed_tools }}
          direct_prompt: ${{ steps.resolve.outputs.direct_prompt }}

      - name: Assert output exists and is non-empty
        run: |
          test -s "${{ steps.resolve.outputs.output_path }}" \
            || (echo "Expected output missing or empty: ${{ steps.resolve.outputs.output_path }}" && exit 1)

      - name: Commit & push changes
        run: |
          git config user.name  "Pipeline Bot"
          git config user.email "pipeline@atriumn.com"
          git add -A
          git commit -m "taskpack:${{ steps.resolve.outputs.pack_id }} issue #${{ inputs.issue_number }} (${{
            steps.resolve.outputs.output_path
          }})" || echo "No changes to commit"
          git push origin "${{ inputs.feature_ref }}" || true

      - name: Emit meta manifest
        run: |
          META="${{ steps.resolve.outputs.output_path }}.meta.json"
          cat > "$META" <<JSON
          {
            "task_pack_id": "${{ steps.resolve.outputs.pack_id }}",
            "task_pack_version": "${{ steps.resolve.outputs.pack_version }}",
            "runner": "${{ inputs.runner }}",
            "output_path": "${{ steps.resolve.outputs.output_path }}",
            "issue_number": "${{ inputs.issue_number }}",
            "feature_ref": "${{ inputs.feature_ref }}",
            "repository": "${{ github.repository }}",
            "commit_sha": "$(git rev-parse HEAD)",
            "status": "completed"
          }
          JSON
          git add "$META"
          git commit -m "meta: $META" || true
          git push origin "${{ inputs.feature_ref }}" || true

      # PR creation is now handled by the GitHub App

      # Check run creation moved to GitHub App for marketplace compatibility

      - name: Comment on issue with artifact link
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const issue_number = Number("${{ inputs.issue_number }}");
            const path = "${{ steps.resolve.outputs.output_path }}";
            const taskPackId = "${{ steps.resolve.outputs.pack_id }}";
            const url = `https://github.com/${owner}/${repo}/blob/${{ inputs.feature_ref }}/${path}`;

            // Phase display names and next actions
            const phaseInfo = {
              'research': { name: 'Research', next: 'plan', nextAction: '/atriumn-approve-research' },
              'plan': { name: 'Plan', next: 'implement', nextAction: '/atriumn-approve-plan' },
              'implement': { name: 'Implementation', next: 'validate', nextAction: '/atriumn-approve-implement' },
              'validate': { name: 'Validation', next: null, nextAction: null }
            };

            const current = phaseInfo[taskPackId] || { name: taskPackId.charAt(0).toUpperCase() + taskPackId.slice(1), next: null, nextAction: null };
            
            // Try to extract summary from the artifact for richer commentary
            let summary = '';
            try {
              if (fs.existsSync(path)) {
                const content = fs.readFileSync(path, 'utf8');
                // Extract summary section if it exists
                const summaryMatch = content.match(/## Summary\s*\n([\s\S]*?)(?=\n##|\n---|\n\*\*|$)/);
                if (summaryMatch) {
                  summary = summaryMatch[1].trim().substring(0, 300);
                  if (summaryMatch[1].trim().length > 300) summary += '...';
                }
              }
            } catch (e) {
              console.log('Could not read artifact for summary:', e.message);
            }

            const body = [
              `âœ… **${current.name} phase complete**`,
              "",
              summary ? `**Key findings:**\n${summary}` : '',
              "",
              `ðŸ“‹ **Artifact:** [\`${path}\`](${url})`,
              current.nextAction ? `ðŸš€ **Next:** Use \`${current.nextAction}\` to proceed to ${current.next}.` : 'ðŸŽ‰ **All phases complete!**'
            ].filter(line => line !== '').join("\n");

            await github.rest.issues.createComment({ owner, repo, issue_number, body });