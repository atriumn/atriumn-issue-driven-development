name: Development Pipeline

on:
  workflow_call:
    inputs:
      repo_name:
        required: true
        type: string
        description: 'Repository name for configuration lookup'
      issue_number:
        required: false
        type: string
        description: 'Issue number if called from issue context'
      branch_name:
        required: false
        type: string
        description: 'Optional branch name override'
      pipeline_id:
        required: false
        type: string
        description: 'Optional pipeline ID for tracking'
      human_validation:
        required: false
        type: boolean
        default: true
        description: 'Enable human validation between phases'
      test_mode:
        required: false
        type: boolean
        default: false
        description: 'Run in test mode'
      trigger_comment:
        required: false
        type: string
        description: 'The comment body that triggered this workflow'
    secrets:
      REPO_TOKEN:
        required: true
        description: 'GitHub token with repository access'

  # Direct repository dispatch (more efficient than issue_comment)
  repository_dispatch:
    types: [pipeline-start, research-complete, approve-research, planning-complete, approve-plan, implementation-complete]

  # For testing - remove in production
  workflow_dispatch:
    inputs:
      repo_name:
        required: true
        type: string
      issue_number:
        required: true
        type: string

jobs:
  # Enhanced configuration loading job
  load-and-validate-config:
    runs-on: ubuntu-latest
    outputs:
      config: ${{ steps.config.outputs.config }}
      config_source: ${{ steps.config.outputs.config_source }}
      base_branch: ${{ steps.config.outputs.base_branch }}
      thoughts_dir: ${{ steps.config.outputs.thoughts_dir }}
      branch_prefix: ${{ steps.config.outputs.branch_prefix }}
      validation_config: ${{ steps.config.outputs.validation_config }}
      team_config: ${{ steps.config.outputs.team_config }}
      workflow_config: ${{ steps.config.outputs.workflow_config }}
    steps:
      - name: Checkout shared workflows
        uses: actions/checkout@v4
        with:
          repository: atriumn/atriumn-shared-workflows
          path: shared-workflows
          
      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo_name }}
          token: ${{ secrets.REPO_TOKEN }}
          path: target-repo
          
      - name: Install configuration validator
        run: |
          # Install yq for YAML processing and python for validation
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          pip install jsonschema pyyaml

      - name: Load and validate configuration
        id: config
        run: |
          cd target-repo
          
          # Try multiple configuration sources in order of preference
          CONFIG_SOURCES=(
            ".github/development-pipeline-config.yml"
            ".github/dev-pipeline.yml"
            "../shared-workflows/configs/${{ inputs.repo_name }}.yml"
            "../shared-workflows/configs/default.yml"
          )
          
          CONFIG_FILE=""
          for source in "${CONFIG_SOURCES[@]}"; do
            if [ -f "$source" ]; then
              CONFIG_FILE="$source"
              echo "Found config: $CONFIG_FILE"
              break
            fi
          done
          
          if [ -z "$CONFIG_FILE" ]; then
            echo "âŒ No configuration file found"
            exit 1
          fi
          
          echo "config_source=$CONFIG_FILE" >> $GITHUB_OUTPUT
          
          # Export CONFIG_FILE for Python script
          export CONFIG_FILE
          
          # Validate configuration against schema
          python3 << 'EOF'
          import yaml
          import jsonschema
          import sys
          import os
          
          # Load schema
          with open('../shared-workflows/configs/schema.yml', 'r') as f:
              schema_doc = yaml.safe_load(f)
              
          # Convert our custom schema to JSON Schema
          def convert_to_json_schema(custom_schema):
              json_schema = {
                  "type": "object",
                  "properties": {},
                  "required": custom_schema['configuration_schema']['required_fields']
              }
              
              for field, definition in custom_schema['field_definitions'].items():
                  json_schema['properties'][field] = {
                      "type": definition['type']
                  }
                  
                  if 'default' in definition:
                      json_schema['properties'][field]['default'] = definition['default']
                  if 'pattern' in definition:
                      json_schema['properties'][field]['pattern'] = definition['pattern']
                  if 'minimum' in definition:
                      json_schema['properties'][field]['minimum'] = definition['minimum']
                  if 'maximum' in definition:
                      json_schema['properties'][field]['maximum'] = definition['maximum']
                      
              return json_schema
          
          schema = convert_to_json_schema(schema_doc)
          
          # Load and validate config
          config_file = os.environ.get('CONFIG_FILE')
          if not config_file:
              print("âŒ CONFIG_FILE environment variable not set")
              sys.exit(1)
          with open(config_file, 'r') as f:
              config = yaml.safe_load(f)
          
          try:
              jsonschema.validate(config, schema)
              print("âœ… Configuration validation passed")
          except jsonschema.ValidationError as e:
              print(f"âŒ Configuration validation failed: {e.message}")
              sys.exit(1)
          
          # Apply defaults for missing optional fields
          default_config = schema_doc['field_definitions']
          for field, definition in default_config.items():
              if field not in config and 'default' in definition:
                  config[field] = definition['default']
                  print(f"Applied default for {field}: {definition['default']}")
          
          # Output processed config
          with open('processed_config.yml', 'w') as f:
              yaml.dump(config, f)
          EOF
          
          # Extract key configuration values
          BASE_BRANCH=$(yq eval '.base_branch' processed_config.yml)
          THOUGHTS_DIR=$(yq eval '.thoughts_directory' processed_config.yml)
          BRANCH_PREFIX=$(yq eval '.branches.prefix' processed_config.yml)
          
          echo "base_branch=$BASE_BRANCH" >> $GITHUB_OUTPUT
          echo "thoughts_dir=$THOUGHTS_DIR" >> $GITHUB_OUTPUT
          echo "branch_prefix=$BRANCH_PREFIX" >> $GITHUB_OUTPUT
          
          # Store specialized config sections - properly escaped for GitHub Actions
          VALIDATION_CONFIG=$(yq eval '.validation' processed_config.yml -o=json -I=0)
          TEAM_CONFIG=$(yq eval '.team' processed_config.yml -o=json -I=0)  
          WORKFLOW_CONFIG=$(yq eval '.workflow_customization' processed_config.yml -o=json -I=0)
          
          # Use heredoc to properly handle JSON with special characters
          {
            echo "validation_config<<EOF"
            echo "$VALIDATION_CONFIG"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          {
            echo "team_config<<EOF"
            echo "$TEAM_CONFIG" 
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          {
            echo "workflow_config<<EOF"
            echo "$WORKFLOW_CONFIG"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          # Store full config for other jobs using heredoc
          CONFIG_JSON=$(yq eval -o=json -I=0 '.' processed_config.yml)
          {
            echo "config<<EOF"
            echo "$CONFIG_JSON"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Report configuration details
        run: |
          echo "ðŸ“ Configuration loaded successfully"
          echo "Source: ${{ steps.config.outputs.config_source }}"
          echo "Repository: ${{ inputs.repo_name }}"
          echo "Base branch: ${{ steps.config.outputs.base_branch }}"
          echo "Thoughts directory: ${{ steps.config.outputs.thoughts_dir }}"
          echo "Branch prefix: ${{ steps.config.outputs.branch_prefix }}"

  # Triggered by: "@atriumn start"
  start-pipeline:
    if: inputs.trigger_comment == '@atriumn start' || github.event.action == 'pipeline-start'
    needs: load-and-validate-config
    runs-on: ubuntu-latest
    outputs:
      branch_name: ${{ steps.branch.outputs.name }}
    steps:
      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo_name }}
          token: ${{ secrets.REPO_TOKEN }}
          fetch-depth: 0
          
      - name: Parse pipeline configuration
        id: parse
        env:
          GH_TOKEN: ${{ secrets.REPO_TOKEN }}
        run: |
          COMMENT="${{ github.event.comment.body }}"
          
          # Extract configuration from comment
          if echo "$COMMENT" | grep -q "Human validation: false"; then
            echo "human_validation=false" >> $GITHUB_OUTPUT
          else
            echo "human_validation=true" >> $GITHUB_OUTPUT
          fi
          
          if echo "$COMMENT" | grep -q "Base branch:"; then
            BASE_OVERRIDE=$(echo "$COMMENT" | grep -o 'Base branch: [^[:space:]]*' | cut -d' ' -f3)
            echo "base_branch_override=$BASE_OVERRIDE" >> $GITHUB_OUTPUT
          fi

      - name: Create feature branch
        id: branch
        env:
          GH_TOKEN: ${{ secrets.REPO_TOKEN }}
        run: |
          # Configure git user for branch operations
          git config user.name "Pipeline Bot"
          git config user.email "pipeline@atriumn.com"
          
          # Use override or config default
          BASE_BRANCH="${{ steps.parse.outputs.base_branch_override || needs.load-and-validate-config.outputs.base_branch }}"
          
          # Get issue number and title (handle both workflow_call and repository_dispatch)
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            ISSUE_NUMBER="${{ github.event.client_payload.issue_number }}"
            ISSUE_TITLE="${{ github.event.client_payload.issue_title }}"
          else
            ISSUE_NUMBER="${{ github.event.issue.number }}"
            ISSUE_TITLE=$(gh issue view $ISSUE_NUMBER --repo ${{ inputs.repo_name }} --json title --jq '.title')
          fi
          
          # Create branch name
          TITLE_SLUG=$(echo "$ISSUE_TITLE" | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
          BRANCH_NAME="${{ needs.load-and-validate-config.outputs.branch_prefix }}issue-$ISSUE_NUMBER-$TITLE_SLUG"
          
          echo "name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          # Get base branch SHA
          BASE_SHA=$(git rev-parse "origin/$BASE_BRANCH")
          
          # Check if branch already exists
          if git show-ref --verify --quiet "refs/remotes/origin/$BRANCH_NAME"; then
            echo "Branch $BRANCH_NAME already exists, checking it out and updating"
            git checkout "$BRANCH_NAME" || git checkout -b "$BRANCH_NAME" "origin/$BRANCH_NAME"
            git pull origin "$BRANCH_NAME"
            echo "âœ… Updated existing branch: $BRANCH_NAME"
          else
            echo "Creating new branch: $BRANCH_NAME"
            git checkout -b "$BRANCH_NAME" "$BASE_SHA"
            git push origin "$BRANCH_NAME"
            echo "âœ… Created new branch: $BRANCH_NAME from $BASE_BRANCH"
          fi

      - name: Create decision record
        env:
          GH_TOKEN: ${{ secrets.REPO_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.branch.outputs.name }}"
          THOUGHTS_DIR="${{ needs.load-and-validate-config.outputs.thoughts_dir }}"
          ISSUE_TITLE=$(gh issue view ${{ github.event.issue.number }} --repo ${{ inputs.repo_name }} --json title --jq '.title')
          
          # Create decision record directory if it doesn't exist
          mkdir -p "$THOUGHTS_DIR/shared/decisions"
          
          # Clean up any existing research for fresh start
          rm -f "$THOUGHTS_DIR/shared/research/"*"issue-${{ github.event.issue.number }}"* || true
          
          # Create initial decision record
          cat > "$THOUGHTS_DIR/shared/decisions/pipeline-issue-${{ github.event.issue.number }}.md" << EOF
          # Pipeline Decision Record - Issue #${{ github.event.issue.number }}: $ISSUE_TITLE
          
          ## Issue Context
          - **Issue**: #${{ github.event.issue.number }}
          - **Title**: $ISSUE_TITLE
          - **Branch**: $BRANCH_NAME
          - **Started**: $(date -Iseconds)
          - **Repository**: ${{ inputs.repo_name }}
          - **Base Branch**: ${{ steps.parse.outputs.base_branch_override || needs.load-and-validate-config.outputs.base_branch }}
          
          ## Current Status
          - **Phase**: Research (Starting)
          - **Completion**: 0%
          - **Next Action**: Research codebase for issue requirements
          
          ## Pipeline Configuration
          - **Human Validation**: ${{ steps.parse.outputs.human_validation }}
          - **Thoughts Directory**: $THOUGHTS_DIR
          
          ---
          
          ## Research Phase (Starting)
          - **Status**: In Progress
          - **Started**: $(date -Iseconds)
          
          EOF
          
          # Commit decision record
          git config user.name "Pipeline Bot"
          git config user.email "pipeline@atriumn.com"
          git add "$THOUGHTS_DIR/shared/decisions/pipeline-issue-${{ github.event.issue.number }}.md"
          git commit -m "Pipeline: Initialize decision record for issue #${{ github.event.issue.number }}"
          git push origin "$BRANCH_NAME"

      - name: Add branch label to issue
        env:
          GH_TOKEN: ${{ secrets.REPO_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.branch.outputs.name }}"
          
          # Create and add pipeline label for tracking
          LABEL_NAME="pipeline-issue-${{ github.event.issue.number }}"
          gh label create "$LABEL_NAME" --color "0366d6" --description "Pipeline: $BRANCH_NAME" --repo ${{ inputs.repo_name }} || true
          gh issue edit ${{ github.event.issue.number }} --add-label "$LABEL_NAME" --repo ${{ inputs.repo_name }}

      - name: Trigger research phase
        env:
          GH_TOKEN: ${{ secrets.REPO_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.branch.outputs.name }}"
          THOUGHTS_DIR="${{ needs.load-and-validate-config.outputs.thoughts_dir }}"
          
          gh issue comment ${{ github.event.issue.number }} --repo ${{ inputs.repo_name }} --body "
          ðŸš€ **Development Pipeline Started**
          
          **Branch**: \`$BRANCH_NAME\` (created from \`${{ steps.parse.outputs.base_branch_override || needs.load-and-validate-config.outputs.base_branch }}\`)
          **Pipeline Mode**: $(if [ '${{ steps.parse.outputs.human_validation }}' = 'true' ]; then echo 'Human validation required'; else echo 'Fully automated'; fi)
          **Decision Record**: \`$THOUGHTS_DIR/shared/decisions/pipeline-issue-${{ github.event.issue.number }}.md\`
          
          ---
          
          @claude Please research the codebase for this issue following our research methodology:
          
          **Context File**: \`$THOUGHTS_DIR/shared/decisions/pipeline-issue-${{ github.event.issue.number }}.md\`
          
          **Research Requirements:**
          - Read any mentioned ticket files completely first
          - Create research document: \`$THOUGHTS_DIR/shared/research/$(date +%Y-%m-%d_%H-%M-%S)_issue-${{ github.event.issue.number }}.md\`
          - Include YAML frontmatter with metadata
          - Update the decision record with your findings
          - Commit research document to your working branch
          
          **Research Structure Required:**
          - YAML frontmatter with metadata (required: date, researcher; recommended: git_commit, branch, issue_number, research_type)
          - Research Question section
          - Summary section with high-level findings
          - Detailed Findings with file:line references
          - Code References section
          - Architecture Insights
          - Historical Context from thoughts/ directory
          
          **IMPORTANT: When finished, post this exact completion signal as a separate comment:**
          
          ðŸŸ£ ATRIUMN-RESEARCH-COMPLETE
          
          (Copy the purple circle and text exactly as shown above)
          
          Please complete the research and commit both documents.
          "

  # Triggered by: Claude completing research
  validate-research:
    if: contains(inputs.trigger_comment || '', 'ðŸŸ£ ATRIUMN-RESEARCH-COMPLETE') || github.event.action == 'research-complete'
    needs: load-and-validate-config
    runs-on: ubuntu-latest
    steps:
      - name: Checkout shared workflows
        uses: actions/checkout@v4
        with:
          repository: atriumn/atriumn-shared-workflows
          path: shared-workflows
          
      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo_name }}
          token: ${{ secrets.REPO_TOKEN }}
          fetch-depth: 0
          path: target-repo
          
      - name: Create pipeline branch name
        id: branch
        run: |
          # Create pipeline branch name from issue title
          ISSUE_TITLE="${{ github.event.issue.title || 'pipeline-task' }}"
          TITLE_SLUG=$(echo "$ISSUE_TITLE" | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
          BRANCH_NAME="feature/issue-${{ github.event.issue.number }}-$TITLE_SLUG"
          
          echo "name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "Pipeline branch: $BRANCH_NAME"

      - name: Find Claude's research branch
        id: claude_branch
        env:
          GH_TOKEN: ${{ secrets.REPO_TOKEN }}
        run: |
          # Look for Claude's branch pattern: claude/issue-XX-*
          echo "Looking for Claude branch with pattern: claude/issue-${{ github.event.issue.number }}-"
          
          # Get all branches and filter with grep
          echo "Getting all branches..."
          gh api "/repos/${{ inputs.repo_name }}/branches" --template '{{range .}}{{.name}}{{"\n"}}{{end}}' > /tmp/branches.txt
          echo "All branches:"
          cat /tmp/branches.txt
          echo "Searching for Claude branch..."
          CLAUDE_BRANCH=$(grep "^claude/issue-${{ github.event.issue.number }}-" /tmp/branches.txt | head -1)
          echo "Found: '$CLAUDE_BRANCH'"
          
          if [ -z "$CLAUDE_BRANCH" ]; then
            echo "âŒ No Claude research branch found for issue #${{ github.event.issue.number }}"
            echo "claude_branch_found=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "claude_branch_found=true" >> $GITHUB_OUTPUT
          echo "name=$CLAUDE_BRANCH" >> $GITHUB_OUTPUT
          echo "Found Claude's research branch: $CLAUDE_BRANCH"

      - name: Checkout pipeline branch and merge research
        run: |
          PIPELINE_BRANCH="${{ steps.branch.outputs.name }}"
          CLAUDE_BRANCH="${{ steps.claude_branch.outputs.name }}"
          
          # Configure git user for merge operations (work in target-repo directory)
          cd target-repo
          git config user.name "Pipeline Bot"
          git config user.email "pipeline@atriumn.com"
          
          # Checkout and update pipeline branch
          git checkout "$PIPELINE_BRANCH"
          git pull origin "$PIPELINE_BRANCH"
          
          # Fetch Claude's branch
          git fetch origin "$CLAUDE_BRANCH:$CLAUDE_BRANCH"
          
          echo "ðŸ”„ Merging research from $CLAUDE_BRANCH into $PIPELINE_BRANCH"
          
          # Merge Claude's research work (allow unrelated histories since Claude creates fresh branches)
          # Use strategy that favors Claude's changes in case of conflicts
          if git merge "$CLAUDE_BRANCH" --no-ff --allow-unrelated-histories -m "Pipeline: Merge research from Claude ($CLAUDE_BRANCH)"; then
            echo "âœ… Clean merge successful"
          else
            echo "âš ï¸ Merge conflicts detected, resolving by favoring Claude's changes..."
            # Reset to Claude's branch state for research files, keep pipeline files
            git checkout "$CLAUDE_BRANCH" -- thoughts/ 2>/dev/null || true
            git add thoughts/ 2>/dev/null || true
            git commit -m "Pipeline: Resolve merge conflicts by adopting Claude's research" --no-edit || true
          fi
          
          # Push the merged result
          git push origin "$PIPELINE_BRANCH"
          
          echo "âœ… Successfully merged Claude's research into pipeline branch"

      - name: Find and validate research document
        id: validate
        run: |
          THOUGHTS_DIR="${{ needs.load-and-validate-config.outputs.thoughts_dir }}"
          
          # Find research document (now in our pipeline branch after merge)
          cd target-repo
          RESEARCH_DOC=$(find "$THOUGHTS_DIR/shared/research" -name "*issue-${{ github.event.issue.number }}*" -type f | head -1)
          
          if [ -z "$RESEARCH_DOC" ]; then
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "error=No research document found for issue #${{ github.event.issue.number }} after merging Claude's work" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "research_doc=$RESEARCH_DOC" >> $GITHUB_OUTPUT
          echo "Found research document: $RESEARCH_DOC"
          
          # Debug: Check directory structure and find validation script
          echo "=== DEBUG: Current working directory ==="
          pwd
          echo "=== DEBUG: Directory contents ==="
          ls -la
          echo "=== DEBUG: Looking for shared-workflows ==="
          find .. -name "shared-workflows" -type d
          echo "=== DEBUG: Looking for validation script ==="
          find .. -name "validate-research.sh" -type f
          echo "=== DEBUG: Check if script exists at expected path ==="
          ls -la ../shared-workflows/scripts/ || echo "../shared-workflows/scripts/ not found"
          
          # Run validation script with config JSON (from target-repo, go up to parent, then to shared-workflows)
          CONFIG_JSON='${{ needs.load-and-validate-config.outputs.config }}'
          SCRIPT_PATH="../shared-workflows/scripts/validate-research.sh"
          echo "=== DEBUG: Trying to run script at: $SCRIPT_PATH ==="
          if [ -f "$SCRIPT_PATH" ]; then
            echo "Script found, executing..."
            if "$SCRIPT_PATH" "$CONFIG_JSON" "$RESEARCH_DOC"; then
              echo "validation_passed=true" >> $GITHUB_OUTPUT
              echo "âœ… Research validation passed"
            else
              echo "validation_passed=false" >> $GITHUB_OUTPUT
              echo "error=Research document validation failed" >> $GITHUB_OUTPUT
              echo "âŒ Research validation failed"
            fi
          else
            echo "âŒ Validation script not found at $SCRIPT_PATH"
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "error=Research document validation failed" >> $GITHUB_OUTPUT
            echo "âŒ Research validation failed"
          fi

      - name: Update decision record with research results
        if: steps.validate.outputs.validation_passed == 'true'
        run: |
          cd target-repo
          THOUGHTS_DIR="${{ needs.load-and-validate-config.outputs.thoughts_dir }}"
          DECISION_FILE="$THOUGHTS_DIR/shared/decisions/pipeline-issue-${{ github.event.issue.number }}.md"
          
          # Update decision record
          cat >> "$DECISION_FILE" << EOF
          
          ### Research Phase (Complete âœ…)
          - **Completed**: $(date -Iseconds)
          - **Document**: ${{ steps.validate.outputs.research_doc }}
          - **Validation**: âœ… Passed automated validation
          - **File References**: $(grep -c '`[^`]*\.[a-z]*:' "${{ steps.validate.outputs.research_doc }}")
          - **Status**: Ready for planning phase
          
          EOF
          
          git config user.name "Pipeline Bot"
          git config user.email "pipeline@atriumn.com"
          git add "$DECISION_FILE"
          git commit -m "Pipeline: Research phase completed for issue #${{ github.event.issue.number }}"
          git push origin ${{ steps.branch.outputs.name }}

      - name: Handle validation failure
        if: steps.validate.outputs.validation_passed == 'false'
        env:
          GH_TOKEN: ${{ secrets.REPO_TOKEN }}
        run: |
          gh issue comment ${{ github.event.issue.number }} --repo ${{ inputs.repo_name }} --body "
          âŒ **Research Validation Failed**
          
          **Error**: ${{ steps.validate.outputs.error }}
          
          **Action Required**: Please review and retry the research phase.
          
          **Common Issues:**
          - Missing required sections in research document
          - Insufficient file references (need at least 3)
          - Invalid YAML frontmatter
          - Document not committed to correct branch
          
          **To Retry**: The research phase can be restarted once issues are resolved.
          "
          exit 1

      - name: Check pipeline mode
        id: mode
        run: |
          # Extract pipeline mode from decision record
          cd target-repo
          THOUGHTS_DIR="${{ needs.load-and-validate-config.outputs.thoughts_dir }}"
          DECISION_FILE="$THOUGHTS_DIR/shared/decisions/pipeline-issue-${{ github.event.issue.number }}.md"
          
          if grep -q "Human Validation.*false" "$DECISION_FILE"; then
            echo "auto_proceed=true" >> $GITHUB_OUTPUT
          else
            echo "auto_proceed=false" >> $GITHUB_OUTPUT
          fi

      - name: Request human approval
        if: steps.validate.outputs.validation_passed == 'true' && steps.mode.outputs.auto_proceed == 'false'
        env:
          GH_TOKEN: ${{ secrets.REPO_TOKEN }}
        run: |
          RESEARCH_DOC="${{ steps.validate.outputs.research_doc }}"
          BRANCH_NAME="${{ steps.branch.outputs.name }}"
          
          gh issue comment ${{ github.event.issue.number }} --repo ${{ inputs.repo_name }} --body "
          ðŸ” **Research Validation Required**
          
          **Automated Validation**: âœ… Passed
          - âœ… Document structure valid
          - âœ… $(grep -c '`[^`]*\.[a-z]*:' "$RESEARCH_DOC") file references found (minimum 3 required)
          - âœ… All required sections present
          - âœ… YAML frontmatter complete
          
          **Research Document**: [\`$RESEARCH_DOC\`](https://github.com/${{ inputs.repo_name }}/blob/$BRANCH_NAME/$RESEARCH_DOC)
          
          **Human Review Needed**: 
          @${{ github.event.issue.user.login }} Please review the research findings:
          
          **Review Questions:**
          - Does the research adequately address the issue requirements?
          - Are the code references sufficient for implementation planning?
          - Any missing architectural considerations?
          - Ready to proceed to planning phase?
          
          **Actions:**
          - âœ… **Approve**: Comment \`approve research\`
          - âŒ **Reject**: Comment \`reject research: [reason]\`
          - ðŸ”„ **Request changes**: Comment \`modify research: [specific requests]\`
          "

      - name: Auto-proceed to planning
        if: steps.validate.outputs.validation_passed == 'true' && steps.mode.outputs.auto_proceed == 'true'
        env:
          GH_TOKEN: ${{ secrets.REPO_TOKEN }}
        run: |
          gh issue comment ${{ github.event.issue.number }} --repo ${{ inputs.repo_name }} --body "
          ðŸ” **Research Validation**: âœ… Passed (automated)
          **Auto-proceeding to Planning Phase**
          
          ---
          
          @claude Please create implementation plan based on this research:
          
          **Read complete pipeline context first:**
          \`${{ needs.load-and-validate-config.outputs.thoughts_dir }}/shared/decisions/pipeline-issue-${{ github.event.issue.number }}.md\`
          
          **Critical Context:**
          - Research findings are documented and validated
          - Use the architectural decisions from research phase
          - Current branch: \`${{ steps.branch.outputs.name }}\`
          
          **Planning Requirements:**
          - Read research document from branch completely
          - Create detailed plan at: \`${{ needs.load-and-validate-config.outputs.thoughts_dir }}/shared/plans/issue-${{ github.event.issue.number }}-implementation.md\`
          - Include phased implementation with clear success criteria
          - Split success criteria into Automated vs Manual verification
          - No unresolved open questions in final plan
          - Update decision record with planning decisions
          
          **Plan Structure Required:**
          - YAML frontmatter with metadata
          - Current State Analysis with file:line references  
          - Desired End State specification
          - \"What We're NOT Doing\" section to prevent scope creep
          - Phased implementation approach
          - Testing Strategy
          - Migration Notes if applicable
          
          **Success Criteria Format:**
          \`\`\`
          #### Automated Verification:
          - [ ] Tests pass: \`make test\`
          - [ ] Linting passes: \`make lint\`
          - [ ] Type checking passes: \`make typecheck\`
          
          #### Manual Verification:  
          - [ ] Feature works correctly in UI
          - [ ] Performance acceptable under load
          - [ ] Edge cases handled properly
          \`\`\`
          
          **Git Operations:**
          \`\`\`bash
          git checkout ${{ steps.branch.outputs.name }}
          git pull origin ${{ steps.branch.outputs.name }}
          git add ${{ needs.load-and-validate-config.outputs.thoughts_dir }}/shared/plans/[filename].md
          git add ${{ needs.load-and-validate-config.outputs.thoughts_dir }}/shared/decisions/pipeline-issue-${{ github.event.issue.number }}.md
          git commit -m \"Plan: Implementation plan for issue #${{ github.event.issue.number }}\"
          git push origin ${{ steps.branch.outputs.name }}
          \`\`\`
          
          Please create the plan following this methodology and commit it to the feature branch.
          "

  # Triggered by: "approve research" comment
  trigger-planning:
    if: github.event_name == 'issue_comment' && contains(github.event.comment.body, 'approve research')
    needs: load-and-validate-config
    runs-on: ubuntu-latest
    steps:
      - name: Get pipeline branch
        id: branch
        env:
          GH_TOKEN: ${{ secrets.REPO_TOKEN }}
        run: |
          # Get branch name from pipeline label description
          BRANCH_NAME=$(gh issue view ${{ github.event.issue.number }} --repo ${{ inputs.repo_name }} --json labels --jq -r '.labels[] | select(.name | startswith("pipeline-issue-")) | .description' | sed 's/^Pipeline: //')
          echo "name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Record approval and trigger planning
        env:
          GH_TOKEN: ${{ secrets.REPO_TOKEN }}
        run: |
          gh issue comment ${{ github.event.issue.number }} --repo ${{ inputs.repo_name }} --body "
          âœ… **Research Approved by @${{ github.event.comment.user.login }}**
          **Proceeding to Planning Phase**
          
          ---
          
          @claude Please create implementation plan based on this research:
          
          **Read complete pipeline context first:**
          \`${{ needs.load-and-validate-config.outputs.thoughts_dir }}/shared/decisions/pipeline-issue-${{ github.event.issue.number }}.md\`
          
          **Critical Context:**
          - Research findings are documented and validated
          - Use the architectural decisions from research phase
          - Current branch: \`${{ steps.branch.outputs.name }}\`
          
          **Planning Requirements:**
          - Read research document from branch completely
          - Create detailed plan at: \`${{ needs.load-and-validate-config.outputs.thoughts_dir }}/shared/plans/issue-${{ github.event.issue.number }}-implementation.md\`
          - Include phased implementation with clear success criteria
          - Split success criteria into Automated vs Manual verification
          - No unresolved open questions in final plan
          - Update decision record with planning decisions
          
          **Plan Structure Required:**
          - YAML frontmatter with metadata
          - Current State Analysis with file:line references  
          - Desired End State specification
          - \"What We're NOT Doing\" section to prevent scope creep
          - Phased implementation approach
          - Testing Strategy
          - Migration Notes if applicable
          
          **Success Criteria Format:**
          \`\`\`
          #### Automated Verification:
          - [ ] Tests pass: \`make test\`
          - [ ] Linting passes: \`make lint\`
          - [ ] Type checking passes: \`make typecheck\`
          
          #### Manual Verification:  
          - [ ] Feature works correctly in UI
          - [ ] Performance acceptable under load
          - [ ] Edge cases handled properly
          \`\`\`
          
          **Git Operations:**
          \`\`\`bash
          git checkout ${{ steps.branch.outputs.name }}
          git pull origin ${{ steps.branch.outputs.name }}
          git add ${{ needs.load-and-validate-config.outputs.thoughts_dir }}/shared/plans/[filename].md
          git add ${{ needs.load-and-validate-config.outputs.thoughts_dir }}/shared/decisions/pipeline-issue-${{ github.event.issue.number }}.md
          git commit -m \"Plan: Implementation plan for issue #${{ github.event.issue.number }}\"
          git push origin ${{ steps.branch.outputs.name }}
          \`\`\`
          
          Please create the plan following this methodology and commit it to the feature branch.
          "